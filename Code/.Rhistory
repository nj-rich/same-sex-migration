library(tidyverse) #for data work
library(data.table) #for data loading
library(haven) #for writing to dta
library(readxl) #for reading in FRED data
#watch these packages for dummies
#install.packages("fastDummies") # --- recipes package might also work or tidymodels? (step_dummy maybe work darn recipe use confusion) (or not- different method) - issue: combo 2 years - check
#library(fastDummies)
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
gc()
state_names <- unique(df_samesex_mm$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df_samesex_mm <- df_samesex_mm %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df_samesex_mm <- df_samesex_mm %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
df <- df_samesex_mm
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc()
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
>summarize
?summarize
view(head(df))
#more efficient way to do summarize? make state sum var? use join?
test <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_same_sex_weighted, na.rm = T))
test <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_same_sex_weighted, na.rm = T))
test <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T))
test <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>%
ungroup
View(test)
rm(test)
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
View(state_year_totals)
glimpse(df)
special_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total)
View(special_totals)
special_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) %>%
unique(YEAR, state_name, RI_excluded_total:OK_excluded_total)
View(special_totals)
special_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) %>%
distinct(YEAR, state_name, RI_excluded_total:OK_excluded_total)
?distinct
?everything
?left_join
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name))
view(head(merged_totals))
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc()
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#more efficient way to do summarize? make state sum var? use join?
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name))
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #darn keeping duplicates
View(merged_totals)
?pivot_wider
test <- merged_totals %>%
pivot_wider(names_from = state_name, values_from = samesex_state_count)
view(test)
for(i in 1:length(state:names)) {
test <- test %>%
mutate(!!state_names[i] = !!sym(state_names[i])/!!sym(total_names[i]))
for(i in 1:length(state:names)) {
state = state_names[i]
total = total_names[i]
test <- test %>%
mutate(!!state = !!sym(state)/!!sym(total))
for(i in 1:length(state:names)) {
state = state_names[i]
total = total_names[i]
test <- test %>%
mutate(!!state := !!sym(state)/!!sym(total))
}
state = state_names[1]
total = total_names[1]
test2 <- test %>%
mutate(!!state := !!sym(state)/!!sym(total))
View(test2)
rm(list = ls())
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc() #use this more liberally?
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #darn keeping duplicates YAY
test <- merged_totals %>%
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state:names)) {
state = state_names[i]
total = total_names[i]
test <- test %>%
mutate(!!state := !!sym(state)/!!sym(total))
}
for(i in 1:length(state:names)) {
state = state_names[i]
total = total_names[i]
test <- test %>%
mutate(column := !!sym(state)/!!sym(total))
}
state = state_names[1]
total = total_names[1]
test2 <- test %>%
mutate(!!state := !!sym(state)/!!sym(total))
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc() #use this more liberally?
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #darn keeping duplicates YAY
#do the division
test <- merged_totals %>%
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state:names)) {
state = state_names[i]
total = total_names[i]
test <- test %>%
mutate(abcd := !!sym(state)/!!sym(total))
}
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc() #use this more liberally?
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #darn keeping duplicates YAY
#do the division
test <- merged_totals %>%
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state:names)) {
state = state_names[i]
total = total_names[i]
test <- test %>%
mutate(abcd = !!sym(state)/!!sym(total))
}
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc() #use this more liberally?
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #darn keeping duplicates YAY
#do the division
test <- merged_totals %>%
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state:names)) {
#  state = state_names[i]
#  total = total_names[i]
test <- test %>%
mutate(abcd = !!sym(state_names[i])/!!sym(total_names[i]))
}
rm(list = ls()))
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc() #use this more liberally?
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #darn keeping duplicates YAY
#do the division
test <- merged_totals %>%
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state_names)) {
state = state_names[i]
total = total_names[i]
test <- test %>%
mutate(!!state := !!sym(state)/!!sym(total))
}
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc() #use this more liberally?
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total) #fine just left join not distinct
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #darn keeping duplicates YAY
View(merged_totals)
rm(list = ls())
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
df <- df_samesex_mm
gc() #use this more liberally?
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total)
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #yay get rid of duplicates
#do the division
samesex_staterate <- merged_totals %>% #oopsy amount of variable names
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state_names)) {
state = state_names[i]
total = total_names[i]
samesex_staterate <- samesex_staterate %>%
mutate(!!state := !!sym(state)/!!sym(total))
}
glimpse(samesex_staterate)
?pivot_longer
#do the division
samesex_staterate <- merged_totals %>% #oopsy amount of variable names
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state_names)) {
state = state_names[i]
total = total_names[i]
samesex_staterate <- samesex_staterate %>%
mutate(!!state := !!sym(state)/!!sym(total))
}
samesex_staterate <- samesex_staterate %>%
select(YEAR, AK:WY) %>%
pivot_longer(AK:WY, names_to = "state_name")
View(samesex_staterate)
rm(list = df, merged_totals, state_year_totals, year_totals, col_name, i, indv_names, state, state_names, total, total_names)
rm(list = (df, merged_totals, state_year_totals, year_totals, col_name, i, indv_names, state, state_names, total, total_names))
rm(df, merged_totals, state_year_totals, year_totals, col_name, i, indv_names, state, state_names, total, total_names)
gc()
#read in data
FRED <- read_excel("/Users/njrich/Desktop/Econ495/same-sex-migration/Data/FRED_statepops/STATEPOP.xls", sheet = "Annual") #for Mac
#FRED <- read_excel("C:\\Users\\njrich\\Downloads\\STATEPOP.xls", sheet = "Annual") #for Windows
#match up columns
FRED <- FRED %>%
pivot_longer(AKPOP:WYPOP, names_to = "state_name") %>%
rename("state_pop" = "value") %>%
rename("YEAR" = "DATE")
#match up strings
FRED <- FRED %>%
mutate(state_name = str_remove(state_name, "POP")) %>%
mutate(YEAR = as.character(YEAR)) %>%
mutate(YEAR = str_remove(YEAR, "-01-01")) %>%
mutate(YEAR = as.numeric(YEAR)) %>%
mutate(state_pop = as.character(state_pop)) %>%
mutate(state_pop = str_remove(state_pop, "\\.")) %>%
mutate(state_pop = as.numeric(state_pop))
gc()
library(tidyverse) #for data work
library(data.table) #for data loading
library(haven) #for writing to dta
library(readxl) #for reading in FRED data
#watch these packages for dummies
#install.packages("fastDummies") # --- recipes package might also work or tidymodels? (step_dummy maybe work darn recipe use confusion) (or not- different method) - issue: combo 2 years - check
#library(fastDummies)
#test making state level pop estimates including state var
df_samesex_mm <- fread("/Users/njrich/Desktop/Econ495/same-sex-migration/test_data.csv") #read in test_code on mac
gc()
df <- df_samesex_mm
state_names <- unique(df$state_name)
indv_names <- paste(state_names, "excluded_indv", sep = "_")
for(i in 1:length(state_names)) {
df <- df %>% #restrict this to gay earlier?
mutate(column = if_else(state_name != state_names[i], in_samesex_weighted, 0)) %>%
rename(!!indv_names[i] := column) #thank you chatgpt
}
total_names <- paste(state_names, "excluded_total", sep = "_")
for(i in 1:length(state_names)) {
col_name <- indv_names[i] #thank you data.frame
df <- df %>%
group_by(YEAR) %>%
mutate(columned = sum(!!sym(col_name))) %>% #this seems to work oi thanks chatgpt
ungroup() %>%
rename(!!total_names[i] := columned)
}
#line up state and overall year totals (does not seem very efficient:()
state_year_totals <- df %>%
group_by(YEAR, state_name) %>%
summarize(samesex_state_count = sum(in_samesex_weighted, na.rm = T)) %>% #WATCH NO USE SPECIAL COUNT HERE
ungroup()
year_totals <- df %>%
select(YEAR, state_name, RI_excluded_total:OK_excluded_total)
merged_totals <- state_year_totals %>%
left_join(year_totals, join_by(YEAR, state_name), multiple = "any") #yay get rid of duplicates
#do the division
samesex_staterate <- merged_totals %>% #oopsy amount of variable names
pivot_wider(names_from = state_name, values_from = samesex_state_count)
for(i in 1:length(state_names)) {
state = state_names[i]
total = total_names[i]
samesex_staterate <- samesex_staterate %>%
mutate(!!state := !!sym(state)/!!sym(total))
}
#clean up variables pivot long to get back to beginning:)
samesex_staterate <- samesex_staterate %>%
select(YEAR, AK:WY) %>%
pivot_longer(AK:WY, names_to = "state_name")
rm(df, merged_totals, state_year_totals, year_totals, col_name, i, indv_names, state, state_names, total, total_names)
#AND IT WORKS NOW MOVING ON NEXT STEP DIVISION:)
